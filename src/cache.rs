mod in_memory;
mod raw;

use std::io::Write;

use thiserror::Error;
use watto::{Pod, StringTable};

use crate::ProguardMapping;

pub use in_memory::IndexedProguard;
pub use raw::ProguardCache;

/// Errors returned while loading/parsing a serialized [`PrgCache`].
///
/// After a PrgCache was successfully parsed via [`PrgCache::parse`], an Error that occurs during
/// access of any data indicates either corruption of the serialized file, or a bug in the
/// converter/serializer.
#[derive(Debug, Error, Clone, Copy, PartialEq, Eq)]
#[non_exhaustive]
pub enum ErrorKind {
    /// The file was generated by a system with different endianness.
    #[error("endianness mismatch")]
    WrongEndianness,
    /// The file magic does not match.
    #[error("wrong format magic")]
    WrongFormat,
    /// The format version in the header is wrong/unknown.
    #[error("unknown SymCache version")]
    WrongVersion,
    /// Header could not be parsed from the cache file.
    #[error("could not read header")]
    InvalidHeader,
    /// File data could not be parsed from the cache file.
    #[error("could not read classes")]
    InvalidClasses,
    /// The header claimed an incorrect number of string bytes.
    #[error("expected {expected} string bytes, found {found}")]
    UnexpectedStringBytes {
        /// Expected number of string bytes.
        expected: usize,
        /// Number of string bytes actually found in the cache file.
        found: usize,
    },
}

/// An error returned when handling a [`PrgCache`].
#[derive(Debug, Error)]
#[error("{kind}")]
pub struct Error {
    pub(crate) kind: ErrorKind,
    #[source]
    pub(crate) source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
}

impl Error {
    /// Returns the corresponding [`ErrorKind`] for this error.
    pub fn kind(&self) -> ErrorKind {
        self.kind
    }
}

impl From<ErrorKind> for Error {
    fn from(kind: ErrorKind) -> Self {
        Self { kind, source: None }
    }
}

pub fn write_proguard_cache<W: Write>(
    mapping: &ProguardMapping,
    writer: &mut W,
) -> std::io::Result<()> {
    let mut classes = Vec::new();
    let mut string_table = StringTable::new();

    let class_index = mapping.create_class_index();

    for (obfuscated, body_range) in class_index.0 {
        let body = &mapping.source[body_range];
        let body = std::str::from_utf8(body).unwrap();
        let obfuscated_offset = string_table.insert(obfuscated) as u32;
        let body_offset = string_table.insert(body) as u32;
        classes.push(raw::Class {
            obfuscated_name_offset: obfuscated_offset,
            body_offset,
        });
    }

    let mut writer = watto::Writer::new(writer);
    let num_classes = classes.len() as u32;
    let string_bytes = string_table.into_bytes();

    let header = raw::Header {
        magic: raw::PRGCACHE_MAGIC,
        version: raw::PRGCACHE_VERSION,
        num_classes,
        string_bytes: string_bytes.len() as u32,
    };

    writer.write_all(header.as_bytes())?;
    writer.align_to(8)?;

    for c in classes {
        writer.write_all(c.as_bytes())?;
    }
    writer.align_to(8)?;

    writer.write_all(&string_bytes)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::{ProguardMapping, StackFrame};

    use super::{in_memory::IndexedProguard, raw::ProguardCache, write_proguard_cache};

    #[test]
    fn test_cache() {
        let source = "\
com.example.MainFragment$EngineFailureException -> com.example.MainFragment$g:
com.example.MainFragment$RocketException -> com.example.MainFragment$d:
com.example.MainFragment$onActivityCreated$4 -> com.example.MainFragment$e:
    1:1:void com.example.MainFragment$Rocket.startEngines():90:90 -> onClick
    1:1:void com.example.MainFragment$Rocket.fly():83 -> onClick
    1:1:void onClick(android.view.View):65 -> onClick
    2:2:void com.example.MainFragment$Rocket.fly():85:85 -> onClick
    2:2:void onClick(android.view.View):65 -> onClick\n";

        let mapping = ProguardMapping::new(source.as_bytes());
        let mut cache = Vec::new();
        write_proguard_cache(&mapping, &mut cache).unwrap();

        let parsed = ProguardCache::parse(&cache).unwrap();
        let in_memory = IndexedProguard::from(parsed);

        assert!(in_memory.get_mapper("com.example.MainFragment$d").is_some());
        assert!(in_memory.get_mapper("com.example.MainFragment$g").is_some());

        let mapper = in_memory.get_mapper("com.example.MainFragment$e").unwrap();
        let remapped: Vec<_> = mapper
            .remap_frame(&StackFrame {
                class: "com.example.MainFragment$e",
                method: "onClick",
                line: 1,
                file: None,
                parameters: None,
            })
            .collect();

        assert_eq!(
            remapped,
            vec![
                StackFrame {
                    class: "com.example.MainFragment$Rocket",
                    method: "startEngines",
                    line: 90,
                    file: None,
                    parameters: None
                },
                StackFrame {
                    class: "com.example.MainFragment$Rocket",
                    method: "fly",
                    line: 83,
                    file: None,
                    parameters: None
                },
                StackFrame {
                    class: "com.example.MainFragment$onActivityCreated$4",
                    method: "onClick",
                    line: 65,
                    file: None,
                    parameters: None
                }
            ]
        );
    }
}
