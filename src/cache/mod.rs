//! A stable on-disk cache format for ProGuard mapping files.
//!
//! # Structure
//! A [`ProguardCache`] file comprises the following parts:
//! * A [header](ProguardCache::header), containing:
//!   - the format version,
//!   - the number of class, member, and member-by-params entries,
//!   - the number of outline mapping pairs,
//!   - the number of rewrite rule entries and components,
//!   - and the length of the string section;
//! * A [list](ProguardCache::classes) of [`Class`](raw::Class) entries;
//! * A [list](ProguardCache::members) of [`Member`](raw::Member) entries;
//! * Another [list](ProguardCache::members_by_params) of `Member` entries, sorted by parameter strings;
//! * A [list] of outline mapping pairs shared by all members;
//! * A [list] of rewrite rule entries and their components;
//! * A [string section](ProguardCache::string_bytes) in which class names, method names, &c. are collected.
//!   Whenever a class or member entry references a string, it is by offset into this section.
//!
//! ## Class entries
//! A class entry contains
//! * an obfuscated and an original name,
//! * optionally a file name,
//! * an offset and length for the class's associated records in the `members` and `members_by_params` section, respectively,
//! * and an `is_synthesized` flag.
//!
//! Class entries are sorted by obfuscated name.
//!
//! ## Member entries
//! A member entry always contains
//! * an obfuscated and an original method name,
//! * a start and end line (1- based and inclusive),
//! * a params string,
//! * an `is_synthesized` flag,
//! * an `is_outline` flag designating outline methods,
//! * an `outline_pairs_offset` and `outline_pairs_len` which slice into the global outline pairs section.
//! * an `rewrite_rules_offset` and `rewrite_rules_len` which slice into the global rewrite rule entries section.
//!
//! It may also contain
//! * an original class name,
//! * an original file name,
//! * and original start and end lines.
//!
//! Member entries in `members` are sorted by the class they belong to, then by
//! obfuscated method name, and finally by the order in which they were encountered
//! in the original proguard file.
//!
//! Member entries in `members_by_params` are sorted by the class they belong to, then by obfuscated
//! method name, then by params string, and finally by the order in which they were encountered in the
//! original proguard file.
//!
//! ## Outline pairs section
//! The outline pairs section is a flat array of pairs mapping an outline-position to a callsite line.
//! Each [`Member`](raw::Member) that carries outline callsite information references a sub-slice of this
//! section via its `outline_pairs_offset` and `outline_pairs_len`. This keeps members fixed-size and
//! enables zero-copy parsing while supporting variable-length metadata.
//!
//! ## Rewrite rules section
//! Rewrite rules are R8's mechanism for post-processing stack frames during deobfuscation.
//! They are stored in two flat arrays:
//!
//! * **Rewrite rule entries**: Each [`RewriteRuleEntry`](raw::RewriteRuleEntry) contains offsets and
//!   lengths into the components array for its conditions and actions.
//! * **Rewrite rule components**: A flat array of [`RewriteComponent`](raw::RewriteComponent) entries,
//!   each representing either a condition (e.g., `throws(Ljava/lang/NullPointerException;)`) or an
//!   action (e.g., `removeInnerFrames(1)`).
//!
//! Each [`Member`](raw::Member) references its rewrite rules via `rewrite_rules_offset` and
//! `rewrite_rules_len`, which slice into the entries array. This two-level indirection keeps
//! members fixed-size while supporting variable numbers of rules with variable numbers of
//! conditions and actions.

mod debug;
mod raw;

use std::borrow::Cow;
use std::cmp::Ordering;
use std::fmt::Write;

use thiserror::Error;

use crate::builder::{RewriteAction, RewriteCondition, RewriteRule};
use crate::mapper::{format_cause, format_frames, format_throwable};
use crate::{java, stacktrace, DeobfuscatedSignature, StackFrame, StackTrace, Throwable};

pub use raw::{ProguardCache, PRGCACHE_VERSION};

/// Result of looking up member mappings for a frame.
/// Contains: (members, prepared_frame, rewrite_rules, had_mappings, outer_source_file)
type MemberLookupResult<'data> = (
    &'data [raw::Member],
    StackFrame<'data>,
    Vec<RewriteRule<'data>>,
    bool,
    Option<&'data str>,
);

/// Errors returned while loading/parsing a serialized [`ProguardCache`].
///
/// After a `ProguardCache` was successfully parsed via [`ProguardCache::parse`], an Error that occurs during
/// access of any data indicates either corruption of the serialized file, or a bug in the
/// converter/serializer.
#[derive(Debug, Error, Clone, Copy, PartialEq, Eq)]
#[non_exhaustive]
pub enum CacheErrorKind {
    /// The file was generated by a system with different endianness.
    #[error("endianness mismatch")]
    WrongEndianness,
    /// The file magic does not match.
    #[error("wrong format magic")]
    WrongFormat,
    /// The format version in the header is wrong/unknown.
    #[error("unknown ProguardCache version")]
    WrongVersion,
    /// Header could not be parsed from the cache file.
    #[error("could not read header")]
    InvalidHeader,
    /// Class data could not be parsed from the cache file.
    #[error("could not read classes")]
    InvalidClasses,
    /// Member data could not be parsed from the cache file.
    #[error("could not read members")]
    InvalidMembers,
    /// The header claimed an incorrect number of string bytes.
    #[error("expected {expected} string bytes, found {found}")]
    UnexpectedStringBytes {
        /// Expected number of string bytes.
        expected: usize,
        /// Number of string bytes actually found in the cache file.
        found: usize,
    },
}

/// An error returned when handling a [`ProguardCache`].
#[derive(Debug, Error)]
#[error("{kind}")]
pub struct CacheError {
    pub(crate) kind: CacheErrorKind,
    #[source]
    pub(crate) source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
}

impl CacheError {
    /// Returns the corresponding [`CacheErrorKind`] for this error.
    pub fn kind(&self) -> CacheErrorKind {
        self.kind
    }
}

impl From<CacheErrorKind> for CacheError {
    fn from(kind: CacheErrorKind) -> Self {
        Self { kind, source: None }
    }
}

impl<'data> ProguardCache<'data> {
    fn get_class(&self, name: &str) -> Option<&raw::Class> {
        let idx = self
            .classes
            .binary_search_by(|c| {
                let Ok(obfuscated) = self.read_string(c.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                obfuscated.cmp(name)
            })
            .ok()?;

        self.classes.get(idx)
    }

    fn get_class_members(&self, class: &raw::Class) -> Option<&'data [raw::Member]> {
        let raw::Class {
            members_offset,
            members_len,
            ..
        } = class;
        let start = *members_offset as usize;
        let end = start.checked_add(*members_len as usize)?;

        self.members.get(start..end)
    }

    fn get_class_members_by_params(&self, class: &raw::Class) -> Option<&'data [raw::Member]> {
        let raw::Class {
            members_by_params_offset,
            members_by_params_len,
            ..
        } = class;
        let start = *members_by_params_offset as usize;
        let end = start.checked_add(*members_by_params_len as usize)?;

        self.members_by_params.get(start..end)
    }

    /// Remaps an obfuscated Class.
    ///
    /// This works on the fully-qualified name of the class, with its complete
    /// module prefix.
    ///
    /// # Examples
    ///
    /// ```
    /// use proguard::{ProguardMapping, ProguardCache};
    /// let mapping = ProguardMapping::new(br#"android.arch.core.executor.ArchTaskExecutor -> a.a.a.a.c:"#);
    /// let mut cache = Vec::new();
    /// ProguardCache::write(&mapping, &mut cache).unwrap();
    /// let cache = ProguardCache::parse(&cache).unwrap();
    ///
    /// let mapped = cache.remap_class("a.a.a.a.c");
    /// assert_eq!(mapped, Some("android.arch.core.executor.ArchTaskExecutor"));
    /// ```
    pub fn remap_class(&self, class: &str) -> Option<&'data str> {
        let class = self.get_class(class)?;
        self.read_string(class.original_name_offset).ok()
    }

    /// Remaps an obfuscated Class Method.
    ///
    /// The `class` argument has to be the fully-qualified obfuscated name of the
    /// class, with its complete module prefix.
    ///
    /// If the `method` can be resolved unambiguously, it will be returned
    /// alongside the remapped `class`, otherwise `None` is being returned.
    pub fn remap_method(&self, class: &str, method: &str) -> Option<(&'data str, &'data str)> {
        let class = self.get_class(class)?;
        let members = self.get_class_members(class)?;

        let matching_members = Self::find_range_by_binary_search(members, |m| {
            let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                return Ordering::Greater;
            };

            obfuscated_name.cmp(method)
        })?;
        let mut iter = matching_members.iter();
        let first = iter.next()?;

        // We conservatively check that all the mappings point to the same method,
        // as we donâ€™t have line numbers to disambiguate.
        // We could potentially skip inlined functions here, but lets rather be conservative.
        let all_matching =
            iter.all(|member| member.original_name_offset == first.original_name_offset);

        if !all_matching {
            return None;
        }

        let original_class = self.read_string(class.original_name_offset).ok()?;
        let original_method = self.read_string(first.original_name_offset).ok()?;

        Some((original_class, original_method))
    }

    fn decode_rewrite_rules(&self, member: &raw::Member) -> Vec<RewriteRule<'data>> {
        let mut rules = Vec::new();
        let start = member.rewrite_rules_offset as usize;
        let len = member.rewrite_rules_len as usize;
        let Some(entries) = self
            .rewrite_rule_entries
            .get(start..start.saturating_add(len))
        else {
            return rules;
        };

        for entry in entries {
            let mut conditions = Vec::new();
            if let Some(condition_components) = self.rewrite_rule_components.get(
                entry.conditions_offset as usize
                    ..entry.conditions_offset.saturating_add(entry.conditions_len) as usize,
            ) {
                for component in condition_components {
                    match component.kind {
                        raw::REWRITE_CONDITION_THROWS => {
                            if let Ok(descriptor) = self.read_string(component.value) {
                                conditions.push(RewriteCondition::Throws(descriptor));
                            }
                        }
                        raw::REWRITE_CONDITION_UNKNOWN => {
                            if let Ok(value) = self.read_string(component.value) {
                                conditions.push(RewriteCondition::Unknown(value));
                            }
                        }
                        _ => {}
                    }
                }
            }

            let mut actions = Vec::new();
            if let Some(action_components) = self.rewrite_rule_components.get(
                entry.actions_offset as usize
                    ..entry.actions_offset.saturating_add(entry.actions_len) as usize,
            ) {
                for component in action_components {
                    match component.kind {
                        raw::REWRITE_ACTION_REMOVE_INNER_FRAMES => {
                            actions
                                .push(RewriteAction::RemoveInnerFrames(component.value as usize));
                        }
                        raw::REWRITE_ACTION_UNKNOWN => {
                            if let Ok(value) = self.read_string(component.value) {
                                actions.push(RewriteAction::Unknown(value));
                            }
                        }
                        _ => {}
                    }
                }
            }

            // Only add rules with at least one condition and one action,
            // matching the validation in parse_rewrite_rule.
            // This guards against corrupt cache data where read_string fails,
            // which would otherwise result in empty conditions that match
            // any exception due to vacuous truth in iter().all().
            if !conditions.is_empty() && !actions.is_empty() {
                rules.push(RewriteRule {
                    conditions,
                    actions,
                });
            }
        }

        rules
    }

    /// Finds member entries for a frame and collects rewrite rules without building frames.
    /// Returns (member_slice, prepared_frame, rewrite_rules, had_mappings).
    fn find_members_and_rules(
        &'data self,
        frame: &StackFrame<'data>,
    ) -> Option<(
        &'data [raw::Member],
        StackFrame<'data>,
        Vec<RewriteRule<'data>>,
        bool,
    )> {
        let class = self.get_class(frame.class)?;
        let original_class = self
            .read_string(class.original_name_offset)
            .unwrap_or(frame.class);

        let mut prepared_frame = frame.clone();
        prepared_frame.class = original_class;

        let method_name = prepared_frame.method;
        let mapping_entries: &[raw::Member] = if let Some(parameters) = prepared_frame.parameters {
            let members = self.get_class_members_by_params(class)?;
            Self::find_range_by_binary_search(members, |m| {
                let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                let params = if m.params_offset != u32::MAX {
                    self.read_string(m.params_offset).unwrap_or_default()
                } else {
                    ""
                };
                (obfuscated_name, params).cmp(&(method_name, parameters))
            })?
        } else {
            let members = self.get_class_members(class)?;
            Self::find_range_by_binary_search(members, |m| {
                let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                obfuscated_name.cmp(method_name)
            })?
        };

        // Collect rewrite rules and check had_mappings by iterating members
        let mut rewrite_rules = Vec::new();
        let mut had_mappings = false;

        if prepared_frame.parameters.is_none() {
            for member in mapping_entries {
                // Check if this member would produce a frame (line matching)
                if member.endline == 0
                    || (prepared_frame.line >= member.startline as usize
                        && prepared_frame.line <= member.endline as usize)
                {
                    had_mappings = true;
                    rewrite_rules.extend(self.decode_rewrite_rules(member));
                }
            }
        } else {
            // With parameters, all members match
            had_mappings = !mapping_entries.is_empty();
            for member in mapping_entries {
                rewrite_rules.extend(self.decode_rewrite_rules(member));
            }
        }

        Some((mapping_entries, prepared_frame, rewrite_rules, had_mappings))
    }

    /// Remaps a single Stackframe.
    ///
    /// Returns zero or more [`StackFrame`]s, based on the information in
    /// the proguard mapping. This can return more than one frame in the case
    /// of inlined functions. In that case, frames are sorted top to bottom.
    pub fn remap_frame<'r: 'data>(
        &'r self,
        frame: &StackFrame<'data>,
    ) -> RemappedFrameIter<'r, 'data> {
        let Some(class) = self.get_class(frame.class) else {
            return RemappedFrameIter::empty();
        };

        for entry in entries {
            let mut conditions = Vec::new();
            if let Some(condition_components) = self.rewrite_rule_components.get(
                entry.conditions_offset as usize
                    ..entry.conditions_offset.saturating_add(entry.conditions_len) as usize,
            ) {
                for component in condition_components {
                    match component.kind {
                        raw::REWRITE_CONDITION_THROWS => {
                            if let Ok(descriptor) = self.read_string(component.value) {
                                conditions.push(RewriteCondition::Throws(descriptor));
                            }
                        }
                        raw::REWRITE_CONDITION_UNKNOWN => {
                            if let Ok(value) = self.read_string(component.value) {
                                conditions.push(RewriteCondition::Unknown(value));
                            }
                        }
                        _ => {}
                    }
                }
            }

            let mut actions = Vec::new();
            if let Some(action_components) = self.rewrite_rule_components.get(
                entry.actions_offset as usize
                    ..entry.actions_offset.saturating_add(entry.actions_len) as usize,
            ) {
                for component in action_components {
                    match component.kind {
                        raw::REWRITE_ACTION_REMOVE_INNER_FRAMES => {
                            actions
                                .push(RewriteAction::RemoveInnerFrames(component.value as usize));
                        }
                        raw::REWRITE_ACTION_UNKNOWN => {
                            if let Ok(value) = self.read_string(component.value) {
                                actions.push(RewriteAction::Unknown(value));
                            }
                        }
                        _ => {}
                    }
                }
            }

            // Only add rules with at least one condition and one action,
            // matching the validation in parse_rewrite_rule.
            // This guards against corrupt cache data where read_string fails,
            // which would otherwise result in empty conditions that match
            // any exception due to vacuous truth in iter().all().
            if !conditions.is_empty() && !actions.is_empty() {
                rules.push(RewriteRule {
                    conditions,
                    actions,
                });
            }
        }

        rules
    }

    /// Finds member entries for a frame and collects rewrite rules without building frames.
    fn find_members_and_rules(
        &'data self,
        frame: &StackFrame<'data>,
    ) -> Option<MemberLookupResult<'data>> {
        let class = self.get_class(frame.class)?;
        let original_class = self
            .read_string(class.original_name_offset)
            .unwrap_or(frame.class);

        // Get the outer source file for synthesis
        let outer_source_file = self.read_string(class.file_name_offset).ok();

        let mut prepared_frame = frame.clone();
        prepared_frame.class = original_class;

        let method_name = prepared_frame.method;
        let mapping_entries: &[raw::Member] = if let Some(parameters) = prepared_frame.parameters {
            let members = self.get_class_members_by_params(class)?;
            Self::find_range_by_binary_search(members, |m| {
                let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                let params = if m.params_offset != u32::MAX {
                    self.read_string(m.params_offset).unwrap_or_default()
                } else {
                    ""
                };
                (obfuscated_name, params).cmp(&(method_name, parameters))
            })?
        } else {
            let members = self.get_class_members(class)?;
            Self::find_range_by_binary_search(members, |m| {
                let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                obfuscated_name.cmp(method_name)
            })?
        };

        // Collect rewrite rules and check had_mappings by iterating members
        let mut rewrite_rules = Vec::new();
        let mut had_mappings = false;

        if prepared_frame.parameters.is_none() {
            for member in mapping_entries {
                // Check if this member would produce a frame (line matching)
                if member.endline == 0
                    || (prepared_frame.line >= member.startline as usize
                        && prepared_frame.line <= member.endline as usize)
                {
                    had_mappings = true;
                    rewrite_rules.extend(self.decode_rewrite_rules(member));
                }
            }
        } else {
            // With parameters, all members match
            had_mappings = !mapping_entries.is_empty();
            for member in mapping_entries {
                rewrite_rules.extend(self.decode_rewrite_rules(member));
            }
        }

        Some((
            mapping_entries,
            prepared_frame,
            rewrite_rules,
            had_mappings,
            outer_source_file,
        ))
    }

    /// Remaps a single stack frame through the complete processing pipeline.
    ///
    /// This method combines:
    /// - Outline frame detection via [`is_outline_frame`](Self::is_outline_frame)
    /// - Frame preparation via [`prepare_frame_for_mapping`](Self::prepare_frame_for_mapping)
    /// - Lazy frame remapping with rewrite rules applied via skip_count
    ///
    /// # Arguments
    /// * `frame` - The frame to remap
    /// * `exception_descriptor` - Optional exception descriptor for rewrite rules (e.g., `Ljava/lang/NullPointerException;`)
    /// * `apply_rewrite` - Whether to apply rewrite rules (typically true only for the first frame after an exception)
    /// * `carried_outline_pos` - Mutable reference to track outline position across frames
    ///
    /// # Returns
    /// - `None` if this is an outline frame (caller should skip, `carried_outline_pos` is updated internally)
    /// - `Some(iterator)` with remapped frames. Use [`RemappedFrameIter::had_mappings`] after collecting
    ///   to detect if rewrite rules cleared all frames (skip if `had_mappings() && collected.is_empty()`)
    pub fn remap_frame<'r>(
        &'r self,
        frame: &StackFrame<'data>,
        exception_descriptor: Option<&str>,
        apply_rewrite: bool,
        carried_outline_pos: &mut Option<usize>,
    ) -> Option<RemappedFrameIter<'r, 'data>>
    where
        'r: 'data,
    {
        if self.is_outline_frame(frame.class, frame.method) {
            *carried_outline_pos = Some(frame.line);
            return None;
        }

        let effective = self.prepare_frame_for_mapping(frame, carried_outline_pos);

        let Some((members, prepared_frame, rewrite_rules, had_mappings, outer_source_file)) =
            self.find_members_and_rules(&effective)
        else {
            return Some(RemappedFrameIter::empty());
        };

        // Compute skip_count from rewrite rules
        let skip_count = if apply_rewrite {
            compute_skip_count(&rewrite_rules, exception_descriptor)
        } else {
            0
        };

        Some(RemappedFrameIter::new(
            self,
            prepared_frame,
            members.iter(),
            skip_count,
            had_mappings,
            outer_source_file,
        ))
    }

    /// Remaps a single stack frame through the complete processing pipeline.
    ///
    /// This method combines:
    /// - Outline frame detection via [`is_outline_frame`](Self::is_outline_frame)
    /// - Frame preparation via [`prepare_frame_for_mapping`](Self::prepare_frame_for_mapping)
    /// - Lazy frame remapping with rewrite rules applied via skip_count
    ///
    /// # Arguments
    /// * `frame` - The frame to remap
    /// * `exception_descriptor` - Optional exception descriptor for rewrite rules (e.g., `Ljava/lang/NullPointerException;`)
    /// * `apply_rewrite` - Whether to apply rewrite rules (typically true only for the first frame after an exception)
    /// * `carried_outline_pos` - Mutable reference to track outline position across frames
    ///
    /// # Returns
    /// - `None` if this is an outline frame (caller should skip, `carried_outline_pos` is updated internally)
    /// - `Some(iterator)` with remapped frames. Use [`RemappedFrameIter::had_mappings`] after collecting
    ///   to detect if rewrite rules cleared all frames (skip if `had_mappings() && collected.is_empty()`)
    pub fn remap_frame_with_context<'r>(
        &'r self,
        frame: &StackFrame<'data>,
        exception_descriptor: Option<&str>,
        apply_rewrite: bool,
        carried_outline_pos: &mut Option<usize>,
    ) -> Option<RemappedFrameIter<'r, 'data>>
    where
        'r: 'data,
    {
        if self.is_outline_frame(frame.class, frame.method) {
            *carried_outline_pos = Some(frame.line);
            return None;
        }

        let effective = self.prepare_frame_for_mapping(frame, carried_outline_pos);

        let Some((members, prepared_frame, rewrite_rules, had_mappings)) =
            self.find_members_and_rules(&effective)
        else {
            return Some(RemappedFrameIter::empty());
        };

        // Compute skip_count from rewrite rules
        let skip_count = if apply_rewrite {
            compute_skip_count(&rewrite_rules, exception_descriptor)
        } else {
            0
        };

        Some(RemappedFrameIter::new(
            self,
            prepared_frame,
            members.iter(),
            skip_count,
            had_mappings,
        ))
    }

    /// Finds the range of elements of `members` for which `f(m) == Ordering::Equal`.
    ///
    /// This works by first binary searching for any element fitting the criteria
    /// and then linearly searching forward and backward from that one to find
    /// the exact range.
    ///
    /// Obviously this only works if the criteria are consistent with the order
    /// of `members`.
    fn find_range_by_binary_search<F>(members: &[raw::Member], f: F) -> Option<&[raw::Member]>
    where
        F: Fn(&raw::Member) -> std::cmp::Ordering,
    {
        // Find any member fitting the criteria by binary search.
        let mid = members.binary_search_by(&f).ok()?;
        let matches_not = |m: &raw::Member| f(m).is_ne();
        // Search backwards from `mid` for a member that doesn't match the
        // criteria. The one after it must be the first one that does.
        let start = members[..mid]
            .iter()
            .rposition(matches_not)
            .map_or(0, |idx| idx + 1);

        // Search forwards from `mid` for a member that doesn't match the
        // criteria. The one before it must be the last one that does.
        let end = members[mid..]
            .iter()
            .position(matches_not)
            .map_or(members.len(), |idx| idx + mid);

        members.get(start..end)
    }

    /// Remaps a throwable which is the first line of a full stacktrace.
    ///
    /// # Example
    ///
    /// ```
    /// use proguard::{ProguardMapping, ProguardCache, Throwable};
    ///
    /// let mapping = ProguardMapping::new(b"com.example.Mapper -> a.b:");
    /// let mut cache = Vec::new();
    /// ProguardCache::write(&mapping, &mut cache).unwrap();
    /// let cache = ProguardCache::parse(&cache).unwrap();
    ///
    /// let throwable = Throwable::try_parse(b"a.b: Crash").unwrap();
    /// let mapped = cache.remap_throwable(&throwable);
    ///
    /// assert_eq!(
    ///     Some(Throwable::with_message("com.example.Mapper", "Crash")),
    ///     mapped
    /// );
    /// ```
    pub fn remap_throwable<'a>(&'a self, throwable: &Throwable<'a>) -> Option<Throwable<'a>> {
        self.remap_class(throwable.class).map(|class| Throwable {
            class,
            message: throwable.message,
        })
    }

    /// Returns the outline mapping pairs slice for a given member.
    fn member_outline_pairs(&self, member: &raw::Member) -> &'data [raw::OutlinePair] {
        let start = member.outline_pairs_offset as usize;
        let end = start + member.outline_pairs_len as usize;
        if start >= self.outline_pairs.len() || end > self.outline_pairs.len() {
            &self.outline_pairs[0..0]
        } else {
            &self.outline_pairs[start..end]
        }
    }

    /// If the previous frame was an outline and carried a position, attempt to
    /// map that outline position to a callsite position for the given method.
    fn map_outline_position(
        &self,
        class: &str,
        method: &str,
        callsite_line: usize,
        pos: usize,
        parameters: Option<&str>,
    ) -> Option<usize> {
        let class = self.get_class(class)?;

        let candidates: &[raw::Member] = if let Some(params) = parameters {
            let members = self.get_class_members_by_params(class)?;
            Self::find_range_by_binary_search(members, |m| {
                let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                let p = self.read_string(m.params_offset).unwrap_or_default();
                (obfuscated_name, p).cmp(&(method, params))
            })?
        } else {
            let members = self.get_class_members(class)?;
            Self::find_range_by_binary_search(members, |m| {
                let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                    return Ordering::Greater;
                };
                obfuscated_name.cmp(method)
            })?
        };

        candidates
            .iter()
            .filter(|m| {
                m.endline == 0
                    || (callsite_line >= m.startline as usize
                        && callsite_line <= m.endline as usize)
            })
            .find_map(|m| {
                self.member_outline_pairs(m)
                    .iter()
                    .find(|pair| pair.outline_pos as usize == pos)
                    .map(|pair| pair.callsite_line as usize)
            })
    }

    /// Determines if a frame refers to an outline method via the method-level flag.
    /// Outline metadata is consistent across all mapping entries for a method, so
    /// we only need to inspect the method metadata instead of individual lines.
    pub fn is_outline_frame(&self, class: &str, method: &str) -> bool {
        let Some(class) = self.get_class(class) else {
            return false;
        };

        let Some(members) = self.get_class_members(class) else {
            return false;
        };

        let Some(candidates) = Self::find_range_by_binary_search(members, |m| {
            let Ok(obfuscated_name) = self.read_string(m.obfuscated_name_offset) else {
                return Ordering::Greater;
            };
            obfuscated_name.cmp(method)
        }) else {
            return false;
        };

        candidates.first().is_some_and(|member| member.is_outline())
    }

    /// Applies any carried outline position to the frame line and returns the adjusted frame.
    pub fn prepare_frame_for_mapping<'a>(
        &self,
        frame: &StackFrame<'a>,
        carried_outline_pos: &mut Option<usize>,
    ) -> StackFrame<'a> {
        let mut effective = frame.clone();
        if let Some(pos) = carried_outline_pos.take() {
            if let Some(mapped) = self.map_outline_position(
                effective.class,
                effective.method,
                effective.line,
                pos,
                effective.parameters,
            ) {
                effective.line = mapped;
            }
        }

        effective
    }

    /// Remaps a complete Java StackTrace, similar to [`Self::remap_stacktrace_typed`] but instead works on
    /// strings as input and output.
    pub fn remap_stacktrace(&self, input: &str) -> Result<String, std::fmt::Error> {
        let mut stacktrace = String::new();
        let mut carried_outline_pos: Option<usize> = None;
        let mut current_exception_descriptor: Option<String> = None;
        let mut next_frame_can_rewrite = false;

        for line in input.lines() {
            if let Some(throwable) = stacktrace::parse_throwable(line) {
                let remapped_throwable = self.remap_throwable(&throwable);
                let descriptor_class = remapped_throwable
                    .as_ref()
                    .map(|t| t.class)
                    .unwrap_or(throwable.class);
                current_exception_descriptor = Some(class_name_to_descriptor(descriptor_class));
                next_frame_can_rewrite = true;
                format_throwable(&mut stacktrace, line, remapped_throwable)?;
                continue;
            }

            if let Some(frame) = stacktrace::parse_frame(line) {
                let Some(iter) = self.remap_frame_with_context(
                    &frame,
                    current_exception_descriptor.as_deref(),
                    next_frame_can_rewrite,
                    &mut carried_outline_pos,
                ) else {
                    // Outline frame, skip (preserve next_frame_can_rewrite for the next real frame)
                    continue;
                };

                next_frame_can_rewrite = false;
                current_exception_descriptor = None;

                let had_mappings = iter.had_mappings();
                let frames: Vec<_> = iter.collect();

                if had_mappings && frames.is_empty() {
                    // Rewrite rules cleared all frames, skip
                    continue;
                }

                format_frames(&mut stacktrace, line, frames.into_iter())?;
                continue;
            }

            if let Some(cause) = line
                .strip_prefix("Caused by: ")
                .and_then(stacktrace::parse_throwable)
            {
                let remapped_cause = self.remap_throwable(&cause);
                let descriptor_class = remapped_cause
                    .as_ref()
                    .map(|t| t.class)
                    .unwrap_or(cause.class);
                current_exception_descriptor = Some(class_name_to_descriptor(descriptor_class));
                next_frame_can_rewrite = true;
                format_cause(&mut stacktrace, line, remapped_cause)?;
                continue;
            }

            current_exception_descriptor = None;
            next_frame_can_rewrite = false;
            writeln!(&mut stacktrace, "{line}")?;
        }
        Ok(stacktrace)
    }

    /// Remaps a complete Java StackTrace.
    pub fn remap_stacktrace_typed<'a>(&'a self, trace: &StackTrace<'a>) -> StackTrace<'a> {
        let exception = trace
            .exception
            .as_ref()
            .and_then(|t| self.remap_throwable(t));
        let exception_descriptor = trace.exception.as_ref().map(|original| {
            let class = exception
                .as_ref()
                .map(|t| t.class)
                .unwrap_or(original.class);
            class_name_to_descriptor(class)
        });

        let mut carried_outline_pos: Option<usize> = None;
        let mut frames = Vec::with_capacity(trace.frames.len());
        let mut next_frame_can_rewrite = exception_descriptor.is_some();
        for f in trace.frames.iter() {
            let Some(iter) = self.remap_frame_with_context(
                f,
                exception_descriptor.as_deref(),
                next_frame_can_rewrite,
                &mut carried_outline_pos,
            ) else {
                // Outline frame, skip (preserve next_frame_can_rewrite for the next real frame)
                continue;
            };
            next_frame_can_rewrite = false;

            let had_mappings = iter.had_mappings();
            let mut remapped: Vec<_> = iter.collect();

            if had_mappings && remapped.is_empty() {
                // Rewrite rules cleared all frames, skip
                continue;
            }

            if remapped.is_empty() {
                frames.push(f.clone());
            } else {
                frames.append(&mut remapped);
            }
        }

        let cause = trace
            .cause
            .as_ref()
            .map(|c| Box::new(self.remap_stacktrace_typed(c)));

        StackTrace {
            exception,
            frames,
            cause,
        }
    }

    /// returns a tuple where the first element is the list of the function
    /// parameters and the second one is the return type
    pub fn deobfuscate_signature(&self, signature: &str) -> Option<DeobfuscatedSignature> {
        java::deobfuscate_bytecode_signature_cache(signature, self).map(DeobfuscatedSignature::new)
    }
}

/// An iterator over remapped stack frames.
///
/// This is returned by [`ProguardCache::remap_frame`].
#[derive(Clone, Debug)]
pub struct RemappedFrameIter<'r, 'data> {
    inner: Option<(
        &'r ProguardCache<'data>,
        StackFrame<'data>,
        std::slice::Iter<'data, raw::Member>,
    )>,
    /// Number of frames to skip from rewrite rules.
    skip_count: usize,
    /// Whether there were mapping entries (for should_skip determination).
    had_mappings: bool,
    /// The source file of the outer class for synthesis.
    outer_source_file: Option<&'data str>,
}

impl<'r, 'data> RemappedFrameIter<'r, 'data> {
    fn empty() -> Self {
        Self {
            inner: None,
            skip_count: 0,
            had_mappings: false,
            outer_source_file: None,
        }
    }

    fn members(
        cache: &'r ProguardCache<'data>,
        frame: StackFrame<'data>,
        members: std::slice::Iter<'data, raw::Member>,
        skip_count: usize,
        had_mappings: bool,
        outer_source_file: Option<&'data str>,
    ) -> Self {
        Self {
            inner: Some((cache, frame, members)),
            skip_count,
            had_mappings,
            outer_source_file,
        }
    }

    /// Returns whether there were mapping entries before rewrite rules were applied.
    ///
    /// After collecting frames, if `had_mappings()` is true but the result is empty,
    /// it means rewrite rules cleared all frames and the caller should skip this frame.
    pub fn had_mappings(&self) -> bool {
        self.had_mappings
    }

    fn next_inner(&mut self) -> Option<StackFrame<'data>> {
        let (cache, frame, members) = self.inner.as_mut()?;
        if frame.parameters.is_none() {
            iterate_with_lines(cache, frame, members, self.outer_source_file)
        } else {
            iterate_without_lines(cache, frame, members, self.outer_source_file)
        }
    }

    fn new(
        cache: &'r ProguardCache<'data>,
        frame: StackFrame<'data>,
        members: std::slice::Iter<'data, raw::Member>,
        skip_count: usize,
        had_mappings: bool,
    ) -> Self {
        Self {
            inner: Some((cache, frame, members)),
            skip_count,
            had_mappings,
        }
    }

    fn next(&mut self) -> Option<Self::Item> {
        // Lazily skip rewrite-removed frames
        while self.skip_count > 0 {
            self.skip_count -= 1;
            self.next_inner()?;
        }
        self.next_inner()
    }
}

impl<'data> Iterator for RemappedFrameIter<'_, 'data> {
    type Item = StackFrame<'data>;

    fn next(&mut self) -> Option<Self::Item> {
        // Lazily skip rewrite-removed frames
        while self.skip_count > 0 {
            self.skip_count -= 1;
            self.next_inner()?;
        }
        self.next_inner()
    }
}

fn iterate_with_lines<'a>(
    cache: &ProguardCache<'a>,
    frame: &mut StackFrame<'a>,
    members: &mut std::slice::Iter<'_, raw::Member>,
    outer_source_file: Option<&str>,
) -> Option<StackFrame<'a>> {
    for member in members {
        // skip any members which do not match our frames line
        if member.endline > 0
            && (frame.line < member.startline as usize || frame.line > member.endline as usize)
        {
            continue;
        }
        // parents of inlined frames don't have an `endline`, and
        // the top inlined frame need to be correctly offset.
        let line = if member.original_endline == u32::MAX
            || member.original_endline == member.original_startline
        {
            member.original_startline as usize
        } else {
            member.original_startline as usize + frame.line - member.startline as usize
        };

        let class = cache
            .read_string(member.original_class_offset)
            .unwrap_or(frame.class);

        let file: Option<Cow<'_, str>> = if member.original_file_offset != u32::MAX {
            let Ok(file_name) = cache.read_string(member.original_file_offset) else {
                continue;
            };

            if file_name == "R8$$SyntheticClass" {
                extract_class_name(class).map(Cow::Borrowed)
            } else {
                Some(Cow::Borrowed(file_name))
            }
        } else {
            // Synthesize from class name (input filename is not reliable)
            synthesize_source_file(class, outer_source_file).map(Cow::Owned)
        };

        let Ok(method) = cache.read_string(member.original_name_offset) else {
            continue;
        };

        return Some(StackFrame {
            class,
            method,
            file,
            line,
            parameters: frame.parameters,
            method_synthesized: member.is_synthesized(),
        });
    }
    None
}

fn iterate_without_lines<'a>(
    cache: &ProguardCache<'a>,
    frame: &mut StackFrame<'a>,
    members: &mut std::slice::Iter<'_, raw::Member>,
    outer_source_file: Option<&str>,
) -> Option<StackFrame<'a>> {
    let member = members.next()?;

    let class = cache
        .read_string(member.original_class_offset)
        .unwrap_or(frame.class);

    let method = cache.read_string(member.original_name_offset).ok()?;

    // Synthesize from class name (input filename is not reliable)
    let file = synthesize_source_file(class, outer_source_file).map(Cow::Owned);

    Some(StackFrame {
        class,
        method,
        file,
        line: 0,
        parameters: frame.parameters,
        method_synthesized: member.is_synthesized(),
    })
}

fn extract_class_name(full_path: &str) -> Option<&str> {
    let after_last_period = full_path.split('.').next_back()?;
    // If the class is an inner class, we need to extract the outer class name
    after_last_period.split('$').next()
}

/// Synthesizes a source file name from a class name.
/// For Kotlin top-level classes ending in "Kt", the suffix is stripped and ".kt" is used.
/// Otherwise, the extension is derived from the reference file, defaulting to ".java".
/// For example: ("com.example.MainKt", Some("Other.java")) -> "Main.kt" (Kt suffix takes precedence)
/// For example: ("com.example.Main", Some("Other.kt")) -> "Main.kt"
/// For example: ("com.example.MainKt", None) -> "Main.kt"
/// For inner classes: ("com.example.Main$Inner", None) -> "Main.java"
fn synthesize_source_file(class_name: &str, reference_file: Option<&str>) -> Option<String> {
    let base = extract_class_name(class_name)?;

    // For Kotlin top-level classes (ending in "Kt"), always use .kt extension and strip suffix
    // This takes precedence over reference_file since Kt suffix is a strong Kotlin indicator
    if base.ends_with("Kt") && base.len() > 2 {
        let kotlin_base = &base[..base.len() - 2];
        return Some(format!("{}.kt", kotlin_base));
    }

    // If we have a reference file, derive extension from it
    if let Some(ext) = reference_file.and_then(|f| f.rfind('.').map(|pos| &f[pos..])) {
        return Some(format!("{}{}", base, ext));
    }

    Some(format!("{}.java", base))
}

/// Converts a Java class name to its JVM descriptor format.
///
/// For example, `java.lang.NullPointerException` becomes `Ljava/lang/NullPointerException;`.
pub fn class_name_to_descriptor(class: &str) -> String {
    let mut descriptor = String::with_capacity(class.len() + 2);
    descriptor.push('L');
    descriptor.push_str(&class.replace('.', "/"));
    descriptor.push(';');
    descriptor
}

/// Computes the number of frames to skip based on rewrite rules.
/// Returns the total skip count from all matching RemoveInnerFrames actions.
fn compute_skip_count(rewrite_rules: &[RewriteRule<'_>], thrown_descriptor: Option<&str>) -> usize {
    let mut skip_count = 0;

    for rule in rewrite_rules {
        let matches = rule.conditions.iter().all(|condition| match condition {
            RewriteCondition::Throws(descriptor) => Some(*descriptor) == thrown_descriptor,
            RewriteCondition::Unknown(_) => false,
        });

        if !matches {
            continue;
        }

        for action in &rule.actions {
            if let RewriteAction::RemoveInnerFrames(count) = action {
                skip_count += count;
            }
        }
    }

    skip_count
}

#[cfg(test)]
mod tests {
    use std::borrow::Cow;

    use crate::{ProguardMapping, StackFrame, StackTrace, Throwable};

    use super::raw::ProguardCache;

    #[test]
    fn stacktrace() {
        let mapping = "\
com.example.MainFragment$EngineFailureException -> com.example.MainFragment$d:
com.example.MainFragment$RocketException -> com.example.MainFragment$e:
com.example.MainFragment$onActivityCreated$4 -> com.example.MainFragment$g:
    1:1:void com.example.MainFragment$Rocket.startEngines():90:90 -> onClick
    1:1:void com.example.MainFragment$Rocket.fly():83 -> onClick
    1:1:void onClick(android.view.View):65 -> onClick
    2:2:void com.example.MainFragment$Rocket.fly():85:85 -> onClick
    2:2:void onClick(android.view.View):65 -> onClick
    ";
        let stacktrace = StackTrace {
            exception: Some(Throwable {
                class: "com.example.MainFragment$e",
                message: Some("Crash!"),
            }),
            frames: vec![
                StackFrame {
                    class: "com.example.MainFragment$g",
                    method: "onClick",
                    line: 2,
                    file: Some(Cow::Borrowed("SourceFile")),
                    parameters: None,
                    method_synthesized: false,
                },
                StackFrame {
                    class: "android.view.View",
                    method: "performClick",
                    line: 7393,
                    file: Some(Cow::Borrowed("View.java")),
                    parameters: None,
                    method_synthesized: false,
                },
            ],
            cause: Some(Box::new(StackTrace {
                exception: Some(Throwable {
                    class: "com.example.MainFragment$d",
                    message: Some("Engines overheating"),
                }),
                frames: vec![StackFrame {
                    class: "com.example.MainFragment$g",
                    method: "onClick",
                    line: 1,
                    file: Some(Cow::Borrowed("SourceFile")),
                    parameters: None,
                    method_synthesized: false,
                }],
                cause: None,
            })),
        };
        let expect = "\
com.example.MainFragment$RocketException: Crash!
    at com.example.MainFragment$Rocket.fly(MainFragment.java:85)
    at com.example.MainFragment$onActivityCreated$4.onClick(MainFragment.java:65)
    at android.view.View.performClick(View.java:7393)
Caused by: com.example.MainFragment$EngineFailureException: Engines overheating
    at com.example.MainFragment$Rocket.startEngines(MainFragment.java:90)
    at com.example.MainFragment$Rocket.fly(MainFragment.java:83)
    at com.example.MainFragment$onActivityCreated$4.onClick(MainFragment.java:65)\n";

        let mapping = ProguardMapping::new(mapping.as_bytes());
        let mut cache = Vec::new();
        ProguardCache::write(&mapping, &mut cache).unwrap();

        let cache = ProguardCache::parse(&cache).unwrap();

        cache.test();

        assert_eq!(
            cache.remap_stacktrace_typed(&stacktrace).to_string(),
            expect,
        );
    }

    #[test]
    fn stacktrace_str() {
        let mapping = "\
com.example.MainFragment$EngineFailureException -> com.example.MainFragment$d:
com.example.MainFragment$RocketException -> com.example.MainFragment$e:
com.example.MainFragment$onActivityCreated$4 -> com.example.MainFragment$g:
    1:1:void com.example.MainFragment$Rocket.startEngines():90:90 -> onClick
    1:1:void com.example.MainFragment$Rocket.fly():83 -> onClick
    1:1:void onClick(android.view.View):65 -> onClick
    2:2:void com.example.MainFragment$Rocket.fly():85:85 -> onClick
    2:2:void onClick(android.view.View):65 -> onClick
    ";

        let stacktrace = "\
com.example.MainFragment$e: Crash!
    at com.example.MainFragment$g.onClick(SourceFile:2)
    at android.view.View.performClick(View.java:7393)
Caused by: com.example.MainFragment$d: Engines overheating
    at com.example.MainFragment$g.onClick(SourceFile:1)
    ... 13 more";

        let expect = "\
com.example.MainFragment$RocketException: Crash!
    at com.example.MainFragment$Rocket.fly(MainFragment.java:85)
    at com.example.MainFragment$onActivityCreated$4.onClick(MainFragment.java:65)
    at android.view.View.performClick(View.java:7393)
Caused by: com.example.MainFragment$EngineFailureException: Engines overheating
    at com.example.MainFragment$Rocket.startEngines(MainFragment.java:90)
    at com.example.MainFragment$Rocket.fly(MainFragment.java:83)
    at com.example.MainFragment$onActivityCreated$4.onClick(MainFragment.java:65)
    ... 13 more\n";

        let mapping = ProguardMapping::new(mapping.as_bytes());
        let mut cache = Vec::new();
        ProguardCache::write(&mapping, &mut cache).unwrap();

        let cache = ProguardCache::parse(&cache).unwrap();

        cache.test();

        assert_eq!(cache.remap_stacktrace(stacktrace).unwrap(), expect);
    }

    #[test]
    fn rewrite_frame_cache_remove_inner_frame() {
        let mapping = "\
some.Class -> a:
    4:4:void other.Class.inlinee():23:23 -> a
    4:4:void caller(other.Class):7 -> a
    # {\"id\":\"com.android.tools.r8.rewriteFrame\",\"conditions\":[\"throws(Ljava/lang/NullPointerException;)\"],\"actions\":[\"removeInnerFrames(1)\"]}
";
        let mapping = ProguardMapping::new(mapping.as_bytes());
        let mut buf = Vec::new();
        ProguardCache::write(&mapping, &mut buf).unwrap();
        let cache = ProguardCache::parse(&buf).unwrap();

        let input = "\
java.lang.NullPointerException: Boom
    at a.a(SourceFile:4)";
        let expect = "\
java.lang.NullPointerException: Boom
    at some.Class.caller(Class.java:7)
";

        assert_eq!(cache.remap_stacktrace(input).unwrap(), expect);
    }

    #[test]
    fn rewrite_frame_cache_or_semantics() {
        let mapping = "\
some.Class -> a:
    4:4:void other.Class.inlinee():23:23 -> call
    4:4:void outer():7 -> call
    # {\"id\":\"com.android.tools.r8.rewriteFrame\",\"conditions\":[\"throws(Ljava/lang/NullPointerException;)\"],\"actions\":[\"removeInnerFrames(1)\"]}
    # {\"id\":\"com.android.tools.r8.rewriteFrame\",\"conditions\":[\"throws(Ljava/lang/IllegalStateException;)\"],\"actions\":[\"removeInnerFrames(1)\"]}
";
        let mapping = ProguardMapping::new(mapping.as_bytes());
        let mut buf = Vec::new();
        ProguardCache::write(&mapping, &mut buf).unwrap();
        let cache = ProguardCache::parse(&buf).unwrap();

        let input_npe = "\
java.lang.NullPointerException: Boom
    at a.call(SourceFile:4)";
        let expected_npe = "\
java.lang.NullPointerException: Boom
    at some.Class.outer(Class.java:7)
";
        assert_eq!(cache.remap_stacktrace(input_npe).unwrap(), expected_npe);

        let input_ise = "\
java.lang.IllegalStateException: Boom
    at a.call(SourceFile:4)";
        let expected_ise = "\
java.lang.IllegalStateException: Boom
    at some.Class.outer(Class.java:7)
";
        assert_eq!(cache.remap_stacktrace(input_ise).unwrap(), expected_ise);
    }

    #[test]
    fn rewrite_frame_removes_all_frames_skips_line() {
        // When rewrite rules remove ALL frames, the line should be skipped entirely
        // (not fall back to original obfuscated frame)
        let mapping = "\
some.Class -> a:
    4:4:void inlined():10:10 -> call
    4:4:void outer():20 -> call
    # {\"id\":\"com.android.tools.r8.rewriteFrame\",\"conditions\":[\"throws(Ljava/lang/NullPointerException;)\"],\"actions\":[\"removeInnerFrames(2)\"]}
some.Other -> b:
    5:5:void method():30 -> run
";
        let mapping = ProguardMapping::new(mapping.as_bytes());
        let mut buf = Vec::new();
        ProguardCache::write(&mapping, &mut buf).unwrap();
        let cache = ProguardCache::parse(&buf).unwrap();

        let input = "\
java.lang.NullPointerException: Boom
    at a.call(SourceFile:4)
    at b.run(SourceFile:5)
";

        // The first frame (a.call) should be completely removed by rewrite rules,
        // not replaced with the original "at a.call(SourceFile:4)"
        let expected = "\
java.lang.NullPointerException: Boom
    at some.Other.method(Other.java:30)
";

        let actual = cache.remap_stacktrace(input).unwrap();
        assert_eq!(actual, expected);
    }

    #[test]
    fn rewrite_frame_removes_all_frames_skips_line_typed() {
        // When rewrite rules remove ALL frames, the frame should be skipped entirely
        // (not fall back to original obfuscated frame)
        let mapping = "\
some.Class -> a:
    4:4:void inlined():10:10 -> call
    4:4:void outer():20 -> call
    # {\"id\":\"com.android.tools.r8.rewriteFrame\",\"conditions\":[\"throws(Ljava/lang/NullPointerException;)\"],\"actions\":[\"removeInnerFrames(2)\"]}
some.Other -> b:
    5:5:void method():30 -> run
";
        let mapping = ProguardMapping::new(mapping.as_bytes());
        let mut buf = Vec::new();
        ProguardCache::write(&mapping, &mut buf).unwrap();
        let cache = ProguardCache::parse(&buf).unwrap();

        let trace = StackTrace {
            exception: Some(Throwable {
                class: "java.lang.NullPointerException",
                message: Some("Boom"),
            }),
            frames: vec![
                StackFrame {
                    class: "a",
                    method: "call",
                    line: 4,
                    file: Some(Cow::Borrowed("SourceFile")),
                    parameters: None,
                    method_synthesized: false,
                },
                StackFrame {
                    class: "b",
                    method: "run",
                    line: 5,
                    file: Some(Cow::Borrowed("SourceFile")),
                    parameters: None,
                    method_synthesized: false,
                },
            ],
            cause: None,
        };

        let remapped = cache.remap_stacktrace_typed(&trace);

        // The first frame should be completely removed by rewrite rules,
        // leaving only the second frame
        assert_eq!(remapped.frames.len(), 1);
        assert_eq!(remapped.frames[0].class, "some.Other");
        assert_eq!(remapped.frames[0].method, "method");
        assert_eq!(remapped.frames[0].line, 30);
    }
}
